using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Newtonsoft.Json;
using UnityEngine;

namespace UnityGameTranslator.Core
{
    /// <summary>
    /// Loads custom SDF fonts from JSON + PNG files generated by msdf-atlas-gen.
    /// Allows users to add support for non-Latin scripts (CJK, Devanagari, Arabic, etc.)
    /// by placing font files in the plugin's fonts/ folder.
    /// </summary>
    public static class CustomFontLoader
    {
        #region JSON Schema (msdf-atlas-gen format)

        [Serializable]
        public class MsdfAtlasData
        {
            public AtlasInfo atlas { get; set; }
            public MetricsInfo metrics { get; set; }
            public List<GlyphInfo> glyphs { get; set; }
            public List<KerningInfo> kerning { get; set; }
        }

        [Serializable]
        public class AtlasInfo
        {
            public string type { get; set; }
            public float distanceRange { get; set; }
            public float size { get; set; }
            public int width { get; set; }
            public int height { get; set; }
            public string yOrigin { get; set; } // "bottom" or "top"
        }

        [Serializable]
        public class MetricsInfo
        {
            public float emSize { get; set; }
            public float lineHeight { get; set; }
            public float ascender { get; set; }
            public float descender { get; set; }
            public float underlineY { get; set; }
            public float underlineThickness { get; set; }
        }

        [Serializable]
        public class GlyphInfo
        {
            public int unicode { get; set; }
            public float advance { get; set; }
            public BoundsInfo planeBounds { get; set; }
            public BoundsInfo atlasBounds { get; set; }
        }

        [Serializable]
        public class BoundsInfo
        {
            public float left { get; set; }
            public float bottom { get; set; }
            public float right { get; set; }
            public float top { get; set; }
        }

        [Serializable]
        public class KerningInfo
        {
            public int unicode1 { get; set; }
            public int unicode2 { get; set; }
            public float advance { get; set; }
        }

        #endregion

        #region Custom Font Info

        /// <summary>
        /// Information about a loaded custom font.
        /// </summary>
        public class CustomFontInfo
        {
            public string Name { get; set; }
            public string JsonPath { get; set; }
            public string PngPath { get; set; }
            public MsdfAtlasData AtlasData { get; set; }
            public Texture2D AtlasTexture { get; set; }
            public object FontAsset { get; set; } // TMP_FontAsset or TMProOld.TMP_FontAsset
            public bool IsLoaded { get; set; }
            public string Error { get; set; }
        }

        #endregion

        // Loaded custom fonts
        private static readonly Dictionary<string, CustomFontInfo> _customFonts = new Dictionary<string, CustomFontInfo>();

        // Cached type references for reflection
        private static Type _tmpFontAssetType;
        private static Type _tmpGlyphType;
        private static Type _tmpTextElementType;
        private static Type _faceInfoType;
        private static bool _typesInitialized;
        private static bool _useAlternateTMP;
        private static bool _existingFontDumped;

        /// <summary>
        /// Gets all available custom fonts (loaded or not).
        /// </summary>
        public static IReadOnlyDictionary<string, CustomFontInfo> CustomFonts => _customFonts;

        /// <summary>
        /// Scans the fonts folder and loads all available custom fonts.
        /// </summary>
        public static void Initialize(string pluginFolder)
        {
            var fontsFolder = Path.Combine(pluginFolder, "fonts");

            if (!Directory.Exists(fontsFolder))
            {
                TranslatorCore.LogInfo($"[CustomFontLoader] No fonts folder found at {fontsFolder}");
                return;
            }

            TranslatorCore.LogInfo($"[CustomFontLoader] Scanning fonts folder: {fontsFolder}");

            // Find all JSON files
            var jsonFiles = Directory.GetFiles(fontsFolder, "*.json");
            int loadedCount = 0;

            foreach (var jsonPath in jsonFiles)
            {
                var fileName = Path.GetFileNameWithoutExtension(jsonPath);
                var pngPath = Path.Combine(fontsFolder, fileName + ".png");

                if (!File.Exists(pngPath))
                {
                    TranslatorCore.LogWarning($"[CustomFontLoader] Missing PNG for {fileName}.json");
                    continue;
                }

                var fontInfo = new CustomFontInfo
                {
                    Name = fileName,
                    JsonPath = jsonPath,
                    PngPath = pngPath
                };

                try
                {
                    // Parse JSON
                    var jsonContent = File.ReadAllText(jsonPath);
                    fontInfo.AtlasData = JsonConvert.DeserializeObject<MsdfAtlasData>(jsonContent);

                    if (fontInfo.AtlasData?.glyphs == null || fontInfo.AtlasData.glyphs.Count == 0)
                    {
                        fontInfo.Error = "No glyphs in JSON";
                        TranslatorCore.LogWarning($"[CustomFontLoader] {fileName}: No glyphs found in JSON");
                    }
                    else
                    {
                        TranslatorCore.LogInfo($"[CustomFontLoader] Found {fileName}: {fontInfo.AtlasData.glyphs.Count} glyphs, {fontInfo.AtlasData.atlas.width}x{fontInfo.AtlasData.atlas.height} atlas");
                        loadedCount++;
                    }
                }
                catch (Exception ex)
                {
                    fontInfo.Error = $"JSON parse error: {ex.Message}";
                    TranslatorCore.LogWarning($"[CustomFontLoader] Failed to parse {fileName}.json: {ex.Message}");
                }

                _customFonts[fileName] = fontInfo;
            }

            TranslatorCore.LogInfo($"[CustomFontLoader] Found {loadedCount} custom font(s)");
        }

        /// <summary>
        /// Gets the names of all available custom fonts.
        /// </summary>
        public static string[] GetCustomFontNames()
        {
            var names = new List<string>();
            foreach (var kvp in _customFonts)
            {
                if (string.IsNullOrEmpty(kvp.Value.Error))
                    names.Add(kvp.Key);
            }
            return names.ToArray();
        }

        /// <summary>
        /// Loads a custom font's texture and creates the TMP_FontAsset.
        /// Call this lazily when the font is actually needed.
        /// </summary>
        public static object LoadCustomFont(string fontName)
        {
            if (!_customFonts.TryGetValue(fontName, out var fontInfo))
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Font not found: {fontName}");
                return null;
            }

            if (fontInfo.IsLoaded && fontInfo.FontAsset != null)
                return fontInfo.FontAsset;

            if (!string.IsNullOrEmpty(fontInfo.Error))
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Cannot load {fontName}: {fontInfo.Error}");
                return null;
            }

            try
            {
                // Load PNG texture
                var pngData = File.ReadAllBytes(fontInfo.PngPath);
                var texture = new Texture2D(2, 2, TextureFormat.RGBA32, false);
                texture.filterMode = FilterMode.Bilinear;

                if (!LoadImageToTexture(texture, pngData))
                {
                    fontInfo.Error = "Failed to load PNG";
                    TranslatorCore.LogWarning($"[CustomFontLoader] Failed to load PNG for {fontName}");
                    return null;
                }

                // For SDF fonts, the distance field is in RGB (grayscale) but TMP expects it in Alpha
                // Convert by copying R channel to Alpha
                ConvertSdfTextureForTMP(texture);

                fontInfo.AtlasTexture = texture;
                TranslatorCore.LogInfo($"[CustomFontLoader] Loaded texture: {texture.width}x{texture.height}, format: {texture.format}");

                // Debug: Check if texture has actual content (not all white/transparent)
                try
                {
                    var pixels = texture.GetPixels(0, 0, Math.Min(10, texture.width), Math.Min(10, texture.height));
                    int nonWhiteCount = 0;
                    foreach (var p in pixels)
                    {
                        if (p.r < 0.99f || p.g < 0.99f || p.b < 0.99f || p.a < 0.99f)
                            nonWhiteCount++;
                    }
                    TranslatorCore.LogInfo($"[CustomFontLoader] Texture sample: {nonWhiteCount}/{pixels.Length} non-white pixels in corner");
                }
                catch (Exception ex)
                {
                    TranslatorCore.LogWarning($"[CustomFontLoader] Could not sample texture: {ex.Message}");
                }

                // Initialize type references if needed
                if (!_typesInitialized)
                    InitializeTypes();

                // Create the font asset
                fontInfo.FontAsset = CreateFontAsset(fontInfo);
                fontInfo.IsLoaded = true;

                if (fontInfo.FontAsset != null)
                {
                    TranslatorCore.LogInfo($"[CustomFontLoader] Successfully created font asset for {fontName}");
                }
                else
                {
                    fontInfo.Error = "Failed to create font asset";
                }

                return fontInfo.FontAsset;
            }
            catch (Exception ex)
            {
                fontInfo.Error = $"Load error: {ex.Message}";
                TranslatorCore.LogError($"[CustomFontLoader] Error loading {fontName}: {ex}");
                return null;
            }
        }

        /// <summary>
        /// Initializes type references for TMP classes via reflection.
        /// </summary>
        private static void InitializeTypes()
        {
            _typesInitialized = true;

            // Try to find TMP types - first check for TMProOld (alternate TMP)
            foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                // Check for TMProOld first
                var oldFontAsset = asm.GetType("TMProOld.TMP_FontAsset");
                if (oldFontAsset != null)
                {
                    _tmpFontAssetType = oldFontAsset;
                    _tmpGlyphType = asm.GetType("TMProOld.TMP_Glyph");
                    _tmpTextElementType = asm.GetType("TMProOld.TMP_TextElement");
                    _faceInfoType = asm.GetType("TMProOld.FaceInfo");
                    _useAlternateTMP = true;
                    TranslatorCore.LogInfo("[CustomFontLoader] Using TMProOld types");
                    return;
                }

                // Check for standard TMPro
                var stdFontAsset = asm.GetType("TMPro.TMP_FontAsset");
                if (stdFontAsset != null && _tmpFontAssetType == null)
                {
                    _tmpFontAssetType = stdFontAsset;
                    _tmpGlyphType = asm.GetType("TMPro.TMP_Glyph");
                    _tmpTextElementType = asm.GetType("TMPro.TMP_TextElement");
                    _faceInfoType = asm.GetType("TMPro.FaceInfo");
                    _useAlternateTMP = false;
                    // Don't return - keep looking for TMProOld
                }
            }

            if (_tmpFontAssetType != null)
            {
                TranslatorCore.LogInfo($"[CustomFontLoader] Using {(_useAlternateTMP ? "TMProOld" : "TMPro")} types");
            }
            else
            {
                TranslatorCore.LogWarning("[CustomFontLoader] No TMP types found!");
            }
        }

        /// <summary>
        /// Creates a TMP_FontAsset from the loaded custom font data.
        /// </summary>
        private static object CreateFontAsset(CustomFontInfo fontInfo)
        {
            if (_tmpFontAssetType == null)
            {
                TranslatorCore.LogWarning("[CustomFontLoader] TMP_FontAsset type not found");
                return null;
            }

            try
            {
                // Try to clone an existing font asset first (better initialization)
                object fontAsset = null;
                var existingFonts = Resources.FindObjectsOfTypeAll(_tmpFontAssetType);
                foreach (var existingFont in existingFonts)
                {
                    if (existingFont != null && existingFont.name != "NotoSansDevanagari" && existingFont.name != "KrutiDev714Normal")
                    {
                        // Clone the existing font
                        fontAsset = UnityEngine.Object.Instantiate(existingFont);
                        ((UnityEngine.Object)fontAsset).name = fontInfo.Name;
                        TranslatorCore.LogInfo($"[CustomFontLoader] Cloned existing font: {existingFont.name}");
                        break;
                    }
                }

                // Fallback to creating new instance if no font to clone
                if (fontAsset == null)
                {
                    fontAsset = ScriptableObject.CreateInstance(_tmpFontAssetType);
                    ((UnityEngine.Object)fontAsset).name = fontInfo.Name;
                    TranslatorCore.LogInfo("[CustomFontLoader] Created new font asset instance");
                }

                var atlas = fontInfo.AtlasData.atlas;
                var metrics = fontInfo.AtlasData.metrics;
                var pointSize = atlas.size;

                // Set atlas texture
                var atlasField = _tmpFontAssetType.GetField("atlas", BindingFlags.Public | BindingFlags.Instance);
                if (atlasField != null)
                {
                    atlasField.SetValue(fontAsset, fontInfo.AtlasTexture);
                }

                // Set material (required for rendering)
                SetupMaterial(fontAsset, fontInfo.AtlasTexture, fontInfo.AtlasData.atlas.distanceRange);

                // Set face info / font info
                SetupFaceInfo(fontAsset, fontInfo, pointSize);

                // Set glyphs
                SetupGlyphs(fontAsset, fontInfo, pointSize);

                return fontAsset;
            }
            catch (Exception ex)
            {
                TranslatorCore.LogError($"[CustomFontLoader] Failed to create font asset: {ex}");
                return null;
            }
        }

        /// <summary>
        /// Dumps the structure of an existing font for debugging.
        /// </summary>
        private static void DumpExistingFontStructure(UnityEngine.Object existingFont)
        {
            try
            {
                // Skip our own custom fonts
                if (existingFont.name == "NotoSansDevanagari" || existingFont.name == "KrutiDev714Normal")
                    return;

                TranslatorCore.LogInfo($"[CustomFontLoader] === Dumping existing font: {existingFont.name} ===");

                var type = existingFont.GetType();

                // List all fields
                var allFields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                TranslatorCore.LogInfo($"[CustomFontLoader] All fields: {string.Join(", ", allFields.Select(f => f.Name))}");

                // Find any field containing "glyph" (case insensitive)
                foreach (var field in allFields)
                {
                    if (field.Name.ToLower().Contains("glyph") || field.Name.ToLower().Contains("character"))
                    {
                        var value = field.GetValue(existingFont);
                        if (value != null)
                        {
                            var valType = value.GetType();
                            if (valType.IsGenericType && valType.GetGenericTypeDefinition() == typeof(List<>))
                            {
                                var countProp = valType.GetProperty("Count");
                                int count = (int)countProp.GetValue(value);
                                TranslatorCore.LogInfo($"[CustomFontLoader] {field.Name}: List with {count} items");

                                // Dump first few items
                                if (count > 0)
                                {
                                    var indexer = valType.GetProperty("Item");
                                    for (int i = 0; i < Math.Min(2, count); i++)
                                    {
                                        var item = indexer.GetValue(value, new object[] { i });
                                        if (item != null)
                                        {
                                            var itemType = item.GetType();
                                            var itemFields = itemType.GetFields(BindingFlags.Public | BindingFlags.Instance);
                                            var fieldValues = itemFields.Select(f => $"{f.Name}={f.GetValue(item)}");
                                            TranslatorCore.LogInfo($"[CustomFontLoader]   [{i}]: {string.Join(", ", fieldValues)}");
                                        }
                                    }
                                }
                            }
                            else if (valType.IsGenericType && valType.GetGenericTypeDefinition() == typeof(Dictionary<,>))
                            {
                                var countProp = valType.GetProperty("Count");
                                int count = (int)countProp.GetValue(value);
                                TranslatorCore.LogInfo($"[CustomFontLoader] {field.Name}: Dictionary with {count} items");
                            }
                            else
                            {
                                TranslatorCore.LogInfo($"[CustomFontLoader] {field.Name}: {valType.Name}");
                            }
                        }
                    }
                }

                // Check for atlas field
                var atlasField = type.GetField("atlas", BindingFlags.Public | BindingFlags.Instance);
                if (atlasField != null)
                {
                    var atlas = atlasField.GetValue(existingFont) as Texture2D;
                    TranslatorCore.LogInfo($"[CustomFontLoader] atlas: {(atlas != null ? $"{atlas.width}x{atlas.height}" : "NULL")}");
                }

                // Check m_fontInfo
                var fontInfoField = type.GetField("m_fontInfo", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                if (fontInfoField != null)
                {
                    var fontInfo = fontInfoField.GetValue(existingFont);
                    if (fontInfo != null)
                    {
                        var fiType = fontInfo.GetType();
                        var fiFields = fiType.GetFields(BindingFlags.Public | BindingFlags.Instance);
                        var fiValues = fiFields.Select(f => $"{f.Name}={f.GetValue(fontInfo)}");
                        TranslatorCore.LogInfo($"[CustomFontLoader] m_fontInfo: {string.Join(", ", fiValues)}");
                    }
                }

                TranslatorCore.LogInfo("[CustomFontLoader] === End dump ===");
                _existingFontDumped = true;
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to dump font structure: {ex.Message}");
            }
        }

        /// <summary>
        /// Sets up the material for the font asset by copying from an existing game font.
        /// </summary>
        private static void SetupMaterial(object fontAsset, Texture2D atlas, float distanceRange)
        {
            try
            {
                Material material = null;

                // First, try to find an existing TMP font and copy its material/shader
                if (_tmpFontAssetType != null)
                {
                    var existingFonts = Resources.FindObjectsOfTypeAll(_tmpFontAssetType);

                    // Debug: dump structure of first existing font (not our custom ones)
                    if (!_existingFontDumped)
                    {
                        foreach (var font in existingFonts)
                        {
                            if (font != null && font.name != "NotoSansDevanagari" && font.name != "KrutiDev714Normal")
                            {
                                DumpExistingFontStructure(font);
                                break;
                            }
                        }
                    }

                    foreach (var existingFont in existingFonts)
                    {
                        if (existingFont == null) continue;

                        // Get material from existing font
                        var matField = _tmpFontAssetType.GetField("material", BindingFlags.Public | BindingFlags.Instance);
                        var matProp = _tmpFontAssetType.GetProperty("material", BindingFlags.Public | BindingFlags.Instance);

                        Material existingMat = null;
                        if (matField != null)
                            existingMat = matField.GetValue(existingFont) as Material;
                        else if (matProp != null)
                            existingMat = matProp.GetValue(existingFont) as Material;

                        if (existingMat != null && existingMat.shader != null)
                        {
                            // Copy the material with our atlas texture
                            material = new Material(existingMat.shader);
                            material.CopyPropertiesFromMaterial(existingMat);
                            material.name = $"{((ScriptableObject)fontAsset).name} Material";
                            material.SetTexture("_MainTex", atlas);

                            // Update texture dimensions for our atlas
                            material.SetFloat("_TextureWidth", atlas.width);
                            material.SetFloat("_TextureHeight", atlas.height);

                            // GradientScale should match the SDF distanceRange from msdf-atlas-gen
                            // This controls the edge softness of the rendered text
                            material.SetFloat("_GradientScale", distanceRange);

                            TranslatorCore.LogInfo($"[CustomFontLoader] Copied material from existing font, shader: {existingMat.shader.name}");
                            TranslatorCore.LogInfo($"[CustomFontLoader] Set _TextureWidth={atlas.width}, _TextureHeight={atlas.height}, _GradientScale={distanceRange}");
                            break;
                        }
                    }
                }

                // Fallback: try to find shader directly
                if (material == null)
                {
                    string[] shaderNames = {
                        "TextMeshPro/Distance Field",
                        "TMPro/Distance Field",
                        "TextMeshPro/Mobile/Distance Field",
                        "TMPro/Mobile/Distance Field"
                    };

                    Shader shader = null;
                    foreach (var name in shaderNames)
                    {
                        shader = Shader.Find(name);
                        if (shader != null)
                        {
                            TranslatorCore.LogInfo($"[CustomFontLoader] Found shader: {name}");
                            break;
                        }
                    }

                    if (shader != null)
                    {
                        material = new Material(shader);
                        material.name = $"{((ScriptableObject)fontAsset).name} Material";
                        material.SetTexture("_MainTex", atlas);
                        material.SetFloat("_TextureWidth", atlas.width);
                        material.SetFloat("_TextureHeight", atlas.height);
                        material.SetFloat("_GradientScale", distanceRange);
                    }
                    else
                    {
                        TranslatorCore.LogWarning("[CustomFontLoader] No TMP shader found!");
                        return;
                    }
                }

                // Set material on font asset
                var materialField = _tmpFontAssetType.GetField("material", BindingFlags.Public | BindingFlags.Instance);
                if (materialField != null)
                {
                    materialField.SetValue(fontAsset, material);
                }
                else
                {
                    var materialProp = _tmpFontAssetType.GetProperty("material", BindingFlags.Public | BindingFlags.Instance);
                    if (materialProp != null && materialProp.CanWrite)
                    {
                        materialProp.SetValue(fontAsset, material);
                    }
                }

                // Debug: verify texture is set on material
                var mainTex = material.GetTexture("_MainTex");
                TranslatorCore.LogInfo($"[CustomFontLoader] Material _MainTex: {(mainTex != null ? $"{mainTex.width}x{mainTex.height}" : "NULL")}");
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to setup material: {ex.Message}");
            }
        }

        /// <summary>
        /// Sets up the face info (font metrics).
        /// </summary>
        private static void SetupFaceInfo(object fontAsset, CustomFontInfo fontInfo, float pointSize)
        {
            var metrics = fontInfo.AtlasData.metrics;
            var atlas = fontInfo.AtlasData.atlas;

            try
            {
                // Find m_fontInfo field
                var fontInfoField = _tmpFontAssetType.GetField("m_fontInfo", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                if (fontInfoField == null)
                {
                    TranslatorCore.LogWarning("[CustomFontLoader] m_fontInfo field not found");
                    return;
                }

                object faceInfo;

                // Create FaceInfo instance
                if (_faceInfoType != null && _faceInfoType.IsValueType)
                {
                    // Struct - create via Activator
                    faceInfo = Activator.CreateInstance(_faceInfoType);
                }
                else if (_faceInfoType != null)
                {
                    // Class - create instance
                    faceInfo = Activator.CreateInstance(_faceInfoType);
                }
                else
                {
                    TranslatorCore.LogWarning("[CustomFontLoader] FaceInfo type not found");
                    return;
                }

                // Set fields using reflection (names may vary between TMP versions)
                float ascender = metrics.ascender * pointSize;
                float descender = metrics.descender * pointSize;
                float capHeight = ascender * 0.8f; // Approximate cap height

                SetFieldValue(faceInfo, "Name", fontInfo.Name);
                SetFieldValue(faceInfo, "PointSize", pointSize);
                SetFieldValue(faceInfo, "Scale", 1f);
                SetFieldValue(faceInfo, "CharacterCount", fontInfo.AtlasData.glyphs.Count);
                SetFieldValue(faceInfo, "LineHeight", metrics.lineHeight * pointSize);
                SetFieldValue(faceInfo, "Baseline", 0f); // Baseline is reference point, typically 0
                SetFieldValue(faceInfo, "Ascender", ascender);
                SetFieldValue(faceInfo, "CapHeight", capHeight);
                SetFieldValue(faceInfo, "Descender", descender);
                SetFieldValue(faceInfo, "CenterLine", (ascender + descender) / 2f);
                SetFieldValue(faceInfo, "SuperscriptOffset", ascender);
                SetFieldValue(faceInfo, "SubscriptOffset", descender * 0.5f);
                SetFieldValue(faceInfo, "SubSize", 0.5f);
                SetFieldValue(faceInfo, "Underline", (metrics.underlineY != 0 ? metrics.underlineY : -0.1f) * pointSize);
                SetFieldValue(faceInfo, "UnderlineThickness", (metrics.underlineThickness != 0 ? metrics.underlineThickness : 0.05f) * pointSize);
                SetFieldValue(faceInfo, "TabWidth", pointSize * 4f); // 4 spaces typically
                SetFieldValue(faceInfo, "Padding", atlas.distanceRange);
                SetFieldValue(faceInfo, "AtlasWidth", (float)atlas.width);
                SetFieldValue(faceInfo, "AtlasHeight", (float)atlas.height);

                fontInfoField.SetValue(fontAsset, faceInfo);

                // Log the configured metrics for debugging
                TranslatorCore.LogInfo($"[CustomFontLoader] Configured FaceInfo: PointSize={pointSize}, Ascender={ascender:F2}, Descender={descender:F2}, LineHeight={metrics.lineHeight * pointSize:F2}");
                TranslatorCore.LogInfo($"[CustomFontLoader] Atlas dimensions: {atlas.width}x{atlas.height}, DistanceRange={atlas.distanceRange}");

                // DEBUG: Verify the values were actually written
                var verifyFaceInfo = fontInfoField.GetValue(fontAsset);
                if (verifyFaceInfo != null)
                {
                    var verifyType = verifyFaceInfo.GetType();
                    var atlasWField = verifyType.GetField("AtlasWidth", BindingFlags.Public | BindingFlags.Instance);
                    var atlasHField = verifyType.GetField("AtlasHeight", BindingFlags.Public | BindingFlags.Instance);
                    var pointSizeField = verifyType.GetField("PointSize", BindingFlags.Public | BindingFlags.Instance);

                    float? verifyW = atlasWField?.GetValue(verifyFaceInfo) as float?;
                    float? verifyH = atlasHField?.GetValue(verifyFaceInfo) as float?;
                    float? verifyPS = pointSizeField?.GetValue(verifyFaceInfo) as float?;

                    TranslatorCore.LogInfo($"[CustomFontLoader] VERIFY m_fontInfo: AtlasWidth={verifyW}, AtlasHeight={verifyH}, PointSize={verifyPS}");
                }
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to setup face info: {ex.Message}");
            }
        }

        /// <summary>
        /// Sets up the glyph list.
        /// </summary>
        private static void SetupGlyphs(object fontAsset, CustomFontInfo fontInfo, float pointSize)
        {
            var atlas = fontInfo.AtlasData.atlas;
            var glyphs = fontInfo.AtlasData.glyphs;
            bool yFlipped = atlas.yOrigin == "bottom";

            try
            {
                // Find glyph list field
                var glyphListField = _tmpFontAssetType.GetField("m_glyphInfoList", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                if (glyphListField == null)
                {
                    TranslatorCore.LogWarning("[CustomFontLoader] m_glyphInfoList field not found");
                    return;
                }

                // Create list of glyphs
                var glyphListType = typeof(List<>).MakeGenericType(_tmpGlyphType ?? _tmpTextElementType ?? typeof(object));
                var glyphList = Activator.CreateInstance(glyphListType);
                var addMethod = glyphListType.GetMethod("Add");

                foreach (var glyphInfo in glyphs)
                {
                    // Create glyph even for characters without visual bounds (like space)
                    // They still need an entry with xAdvance for proper spacing
                    var glyph = CreateGlyph(glyphInfo, atlas, pointSize, yFlipped);
                    if (glyph != null)
                    {
                        addMethod.Invoke(glyphList, new[] { glyph });
                    }
                }

                glyphListField.SetValue(fontAsset, glyphList);

                // Also build the character dictionary for lookups
                BuildCharacterDictionary(fontAsset, glyphList);

                TranslatorCore.LogInfo($"[CustomFontLoader] Added {glyphs.Count} glyphs");
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to setup glyphs: {ex.Message}");
            }
        }

        private static bool _glyphFieldsLogged = false;

        /// <summary>
        /// Creates a single glyph object.
        /// </summary>
        private static object CreateGlyph(GlyphInfo glyphInfo, AtlasInfo atlas, float pointSize, bool yFlipped)
        {
            try
            {
                var glyphType = _tmpGlyphType ?? _tmpTextElementType;
                if (glyphType == null)
                    return null;

                // Log available fields once for debugging
                if (!_glyphFieldsLogged)
                {
                    _glyphFieldsLogged = true;
                    var fields = glyphType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                    TranslatorCore.LogInfo($"[CustomFontLoader] Glyph type: {glyphType.FullName}, fields: {string.Join(", ", fields.Select(f => f.Name + ":" + f.FieldType.Name))}");
                }

                var glyph = Activator.CreateInstance(glyphType);

                var ab = glyphInfo.atlasBounds;
                var pb = glyphInfo.planeBounds;

                // Calculate atlas coordinates
                // For characters without visual bounds (like space), use zero dimensions
                float x = 0, y = 0, width = 0, height = 0;

                if (ab != null)
                {
                    // Shrink the region slightly to avoid sampling adjacent glyphs
                    float shrink = atlas.distanceRange * 0.82f;

                    x = ab.left + shrink;
                    // yFlipped (yOrigin="bottom") means we need to flip Y for TMP's coordinate system
                    y = yFlipped ? (atlas.height - ab.top + shrink) : (ab.top + shrink);
                    width = Math.Max(1, ab.right - ab.left - shrink * 2);
                    height = Math.Max(1, ab.top - ab.bottom - shrink * 2);
                }

                // Calculate offsets (planeBounds are in em units, multiply by pointSize)
                float xOffset = (pb?.left ?? 0) * pointSize;
                float yOffset = (pb?.top ?? 0) * pointSize;
                float xAdvance = glyphInfo.advance * pointSize;

                // Set glyph properties
                SetFieldValue(glyph, "id", glyphInfo.unicode);
                SetFieldValue(glyph, "x", x);
                SetFieldValue(glyph, "y", y);
                SetFieldValue(glyph, "width", width);
                SetFieldValue(glyph, "height", height);
                SetFieldValue(glyph, "xOffset", xOffset);
                SetFieldValue(glyph, "yOffset", yOffset);
                SetFieldValue(glyph, "xAdvance", xAdvance);
                SetFieldValue(glyph, "scale", 1f);

                // Log first few glyphs for debugging (Latin A-C and first Devanagari)
                bool shouldLog = (glyphInfo.unicode >= 65 && glyphInfo.unicode <= 67) // A, B, C
                    || (glyphInfo.unicode >= 2309 && glyphInfo.unicode <= 2315); // First Devanagari consonants
                if (shouldLog)
                {
                    TranslatorCore.LogInfo($"[CustomFontLoader] Glyph U+{glyphInfo.unicode:X4}: x={x}, y={y}, w={width}, h={height}, xOff={xOffset}, yOff={yOffset}, xAdv={xAdvance}");
                }

                return glyph;
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to create glyph {glyphInfo.unicode}: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Builds the character dictionary for fast lookups.
        /// </summary>
        private static void BuildCharacterDictionary(object fontAsset, object glyphList)
        {
            try
            {
                var dictField = _tmpFontAssetType.GetField("m_characterDictionary", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
                if (dictField == null)
                    return;

                var glyphType = _tmpGlyphType ?? _tmpTextElementType;
                var dictType = typeof(Dictionary<,>).MakeGenericType(typeof(int), glyphType);
                var dict = Activator.CreateInstance(dictType);
                var dictAdd = dictType.GetMethod("Add");

                var listType = glyphList.GetType();
                var countProp = listType.GetProperty("Count");
                var indexer = listType.GetProperty("Item");

                int count = (int)countProp.GetValue(glyphList);
                for (int i = 0; i < count; i++)
                {
                    var glyph = indexer.GetValue(glyphList, new object[] { i });
                    var idField = glyphType.GetField("id", BindingFlags.Public | BindingFlags.Instance);
                    if (idField != null)
                    {
                        int id = (int)idField.GetValue(glyph);
                        try
                        {
                            dictAdd.Invoke(dict, new object[] { id, glyph });
                        }
                        catch { } // Ignore duplicates
                    }
                }

                dictField.SetValue(fontAsset, dict);

                // Log dictionary size for debugging
                var dictCount = dictType.GetProperty("Count");
                int dictSize = (int)dictCount.GetValue(dict);
                TranslatorCore.LogInfo($"[CustomFontLoader] Built character dictionary with {dictSize} entries");
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to build character dictionary: {ex.Message}");
            }
        }

        /// <summary>
        /// Helper to set a field value via reflection.
        /// </summary>
        private static void SetFieldValue(object obj, string fieldName, object value)
        {
            if (obj == null) return;

            var type = obj.GetType();
            var field = type.GetField(fieldName, BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
            if (field != null)
            {
                try
                {
                    // Convert value if needed
                    if (value != null && field.FieldType != value.GetType())
                    {
                        value = Convert.ChangeType(value, field.FieldType);
                    }
                    field.SetValue(obj, value);
                }
                catch { }
            }
        }

        // Cached LoadImage method
        private static MethodInfo _loadImageMethod;
        private static bool _loadImageMethodSearched;

        /// <summary>
        /// Loads image data into a Texture2D using reflection to call ImageConversion.LoadImage.
        /// This avoids compile-time dependency on ImageConversionModule.
        /// </summary>
        private static bool LoadImageToTexture(Texture2D texture, byte[] data)
        {
            if (texture == null || data == null || data.Length == 0)
                return false;

            // Find the LoadImage method once
            if (!_loadImageMethodSearched)
            {
                _loadImageMethodSearched = true;

                // Try to find ImageConversion.LoadImage(Texture2D, byte[])
                foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
                {
                    var imageConvType = asm.GetType("UnityEngine.ImageConversion");
                    if (imageConvType != null)
                    {
                        _loadImageMethod = imageConvType.GetMethod("LoadImage",
                            BindingFlags.Public | BindingFlags.Static,
                            null,
                            new Type[] { typeof(Texture2D), typeof(byte[]) },
                            null);

                        if (_loadImageMethod != null)
                        {
                            TranslatorCore.LogInfo("[CustomFontLoader] Found ImageConversion.LoadImage method");
                            break;
                        }
                    }
                }

                // If not found, try extension method on Texture2D (older Unity)
                if (_loadImageMethod == null)
                {
                    _loadImageMethod = typeof(Texture2D).GetMethod("LoadImage",
                        BindingFlags.Public | BindingFlags.Instance,
                        null,
                        new Type[] { typeof(byte[]) },
                        null);

                    if (_loadImageMethod != null)
                    {
                        TranslatorCore.LogInfo("[CustomFontLoader] Found Texture2D.LoadImage method");
                    }
                }

                if (_loadImageMethod == null)
                {
                    TranslatorCore.LogWarning("[CustomFontLoader] No LoadImage method found - PNG loading will fail");
                }
            }

            if (_loadImageMethod == null)
                return false;

            try
            {
                object result;
                if (_loadImageMethod.IsStatic)
                {
                    // ImageConversion.LoadImage(texture, data)
                    result = _loadImageMethod.Invoke(null, new object[] { texture, data });
                }
                else
                {
                    // texture.LoadImage(data)
                    result = _loadImageMethod.Invoke(texture, new object[] { data });
                }

                return result is bool b && b;
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] LoadImage failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Converts an SDF texture for TMP compatibility.
        /// msdf-atlas-gen outputs SDF as grayscale in RGB channels, but TMP reads distance from Alpha channel.
        /// This method copies the R channel to Alpha to make the texture compatible with TMP shaders.
        /// </summary>
        private static void ConvertSdfTextureForTMP(Texture2D texture)
        {
            if (texture == null) return;

            try
            {
                var pixels = texture.GetPixels();
                bool needsConversion = false;

                // Check if we need conversion: if alpha is mostly 1.0 but R varies, we need to copy R to A
                int sampleCount = Math.Min(100, pixels.Length);
                int alphaOnes = 0;
                int rVariation = 0;
                float lastR = -1;

                for (int i = 0; i < sampleCount; i++)
                {
                    int idx = i * (pixels.Length / sampleCount);
                    if (pixels[idx].a > 0.99f) alphaOnes++;
                    if (lastR >= 0 && Math.Abs(pixels[idx].r - lastR) > 0.01f) rVariation++;
                    lastR = pixels[idx].r;
                }

                // If alpha is constant but R varies, we need to copy R to A
                needsConversion = alphaOnes > sampleCount * 0.9f && rVariation > sampleCount * 0.1f;

                if (needsConversion)
                {
                    TranslatorCore.LogInfo("[CustomFontLoader] Converting SDF texture: copying R channel to Alpha");
                    for (int i = 0; i < pixels.Length; i++)
                    {
                        // Copy R channel to Alpha, keep RGB as white for proper rendering
                        pixels[i] = new Color(1f, 1f, 1f, pixels[i].r);
                    }
                    texture.SetPixels(pixels);
                    texture.Apply();
                    TranslatorCore.LogInfo("[CustomFontLoader] SDF texture conversion complete");
                }
                else
                {
                    TranslatorCore.LogInfo("[CustomFontLoader] Texture appears to already have distance in Alpha channel");
                }
            }
            catch (Exception ex)
            {
                TranslatorCore.LogWarning($"[CustomFontLoader] Failed to convert SDF texture: {ex.Message}");
            }
        }
    }
}
